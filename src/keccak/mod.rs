use std::ops::{Index, IndexMut};

mod step_mappings;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct State {
    data: [[u64; 5]; 5],
}

impl State {
    pub fn new() -> Self {
        State { data: [[0; 5]; 5] }
    }

    fn xor(&mut self, rhs: &[u64]) {
        let (mut x, mut y) = (0, 0);
        for word in rhs {
            self.data[x][y] ^= *word;
            (x, y) = Self::tick(x, y);
        }
    }

    fn first_n_bytes(&self, n: usize) -> Vec<u8> {
        let mut count = 1;
        let (mut x, mut y) = (0, 0);
        let mut word_cursor = 1;
        let mut current_word = self.data[x][y];
        let mut out = vec![current_word as u8];

        loop {
            // we've gotten all the bytes we're looking for.
            if count == n {
                break;
            }
            // The intra-word cursor has reached 8, so we need to move to the
            // next word, update the matrix indices and reset current word.
            if word_cursor % 8 == 0 {
                (x, y) = Self::tick(x, y);
                current_word = self.data[x][y];
                word_cursor = 0;
            }
            out.push((current_word >> (word_cursor * 8)) as u8);
            count += 1;
            word_cursor += 1;
        }

        out
    }

    #[inline]
    fn tick(x: usize, y: usize) -> (usize, usize) {
        if x == 4 { (0, y + 1) } else { (x + 1, y) }
    }
}

impl Index<usize> for State {
    type Output = [u64; 5];

    fn index(&self, index: usize) -> &Self::Output {
        &self.data[index]
    }
}

impl IndexMut<usize> for State {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.data[index]
    }
}

impl<T: AsRef<[u8]>> From<T> for State {
    fn from(bytes: T) -> Self {
        let mut state = Self::new();
        let mut x = 0;
        let mut y = 0;
        for i in 0..25 {
            let cursor = i * 8;
            let u64slice = &bytes.as_ref()[cursor..cursor + 8];
            let mut val: u64 = 0;
            for j in 0..8 {
                val |= (u64slice[j] as u64) << (j * 8);
            }
            state[x][y] = val;
            (x, y) = Self::tick(x, y);
        }
        state
    }
}

struct Sponge<F, const N: usize> {
    state: State,
    f: F,
    buffer: [u8; N],
    cursor: usize,
}

impl<F, const N: usize> Sponge<F, N>
where
    F: Fn(&mut State),
{
    fn absorb(f: F, cap: usize, input: &[u8]) -> Self {
        let mut state = State::new();
        let mut cursor = 0;
        let mut words = vec![];
        loop {
            if cursor == input.len() {
                break;
            }
            words.push(
                (input[cursor] as u64)
                    | ((input[cursor + 1] as u64) << 8)
                    | ((input[cursor + 2] as u64) << 16)
                    | ((input[cursor + 3] as u64) << 24)
                    | ((input[cursor + 4] as u64) << 32)
                    | ((input[cursor + 5] as u64) << 40)
                    | ((input[cursor + 6] as u64) << 48)
                    | ((input[cursor + 7] as u64) << 56),
            );
            cursor += 8;
        }
        let num_chunks = words.len() / (N / 8);
        for _ in 0..num_chunks {
            let rest = words.split_off(N / 8);
            words.append(&mut [0].repeat(cap));
            state.xor(&words);
            f(&mut state);
            words = rest;
        }

        let mut buffer = [0; N];
        buffer.copy_from_slice(&state.first_n_bytes(N));

        Self {
            cursor: 0,
            f,
            buffer,
            state,
        }
    }

    fn squeeze(&mut self, num_bytes: usize) -> Vec<u8> {
        if self.cursor + num_bytes >= N {
            self.cursor = 0;
            (self.f)(&mut self.state);
            self.buffer.copy_from_slice(&self.state.first_n_bytes(N));
        }
        let mut out = vec![];
        for _ in 0..num_bytes {
            out.push(self.buffer[self.cursor]);
            self.cursor += 1;
        }
        out
    }
}

/// Implements KECCAK-p, in place, on `state`.
pub fn keccak_p(state: &mut State) {
    for i in 0..24 {
        step_mappings::theta(state);
        step_mappings::rho(state);
        step_mappings::pi(state);
        step_mappings::chi(state);
        step_mappings::iota(i, state);
    }
}

fn pad101(dom: u8, mod_len: usize, len: usize) -> Vec<u8> {
    let pad_len = mod_len - ((len + 2) % mod_len);
    let mut out = vec![dom];
    out.append(&mut [0].repeat(pad_len));
    out.push(0x80);
    out
}

fn absorb<F>(f: F, rate: usize, cap: usize, state: &mut State, input: &[u8])
where
    F: Fn(&mut State),
{
    let mut cursor = 0;
    let mut words = vec![];
    loop {
        if cursor == input.len() {
            break;
        }
        words.push(
            (input[cursor] as u64)
                | ((input[cursor + 1] as u64) << 8)
                | ((input[cursor + 2] as u64) << 16)
                | ((input[cursor + 3] as u64) << 24)
                | ((input[cursor + 4] as u64) << 32)
                | ((input[cursor + 5] as u64) << 40)
                | ((input[cursor + 6] as u64) << 48)
                | ((input[cursor + 7] as u64) << 56),
        );
        cursor += 8;
    }
    let num_chunks = words.len() / rate;
    for _ in 0..num_chunks {
        let rest = words.split_off(rate);
        words.append(&mut [0].repeat(cap));
        state.xor(&words);
        f(state);
        words = rest;
    }
}

fn squeeze<F>(f: F, rate: usize, state: &mut State, out_len: usize) -> Vec<u8>
where
    F: Fn(&mut State),
{
    let mut out = state.first_n_bytes(rate);
    loop {
        if out.len() >= out_len {
            out.truncate(out_len);
            break;
        }
        f(state);
        out.append(&mut state.first_n_bytes(rate));
    }
    out
}

/// implements keccak as found in FIPS 201.
///
/// Capacity (`cap`) and d (`out_len`) are in bits here, as specified. However,
/// they are converted to lengths in quad-words and bytes respectively before
/// using the sponge functions to match these functions assumptions.
pub fn keccak<T: AsRef<[u8]>, const C: usize, const R: usize>(
    dom: u8,
    out_len: usize,
    input: &T,
) -> Vec<u8> {
    let mut state = State::new();
    let qwcap = C / 8 / 8;
    let byte_ol = out_len / 8;
    let mut padded_input = input.as_ref().to_vec();
    padded_input.append(&mut pad101(dom, R / 8, input.as_ref().len()));
    absorb(keccak_p, R / 8 / 8, qwcap, &mut state, &*padded_input);
    squeeze(keccak_p, R / 8, &mut state, byte_ol)
}

pub fn sha3_512<T: AsRef<[u8]>>(input: &T) -> Vec<u8> {
    keccak::<_, 1024, { 1600 - 1024 }>(0x06, 512, input)
}

#[cfg(test)]
mod test {
    use super::*;

    macro_rules! expl {

        ($( $val:literal )* ) => {
            {
              State::from(vec![$($val),*])
            }
        };
    }

    #[test]
    fn keccak_p_padded_vector() {
        let mut state = expl![
            0x06 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x80 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
            0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
        ];

        let expected_state = expl![
            0xA6 0x9F 0x73 0xCC 0xA2 0x3A 0x9A 0xC5 0xC8 0xB5 0x67 0xDC 0x18 0x5A 0x75 0x6E
            0x97 0xC9 0x82 0x16 0x4F 0xE2 0x58 0x59 0xE0 0xD1 0xDC 0xC1 0x47 0x5C 0x80 0xA6
            0x15 0xB2 0x12 0x3A 0xF1 0xF5 0xF9 0x4C 0x11 0xE3 0xE9 0x40 0x2C 0x3A 0xC5 0x58
            0xF5 0x00 0x19 0x9D 0x95 0xB6 0xD3 0xE3 0x01 0x75 0x85 0x86 0x28 0x1D 0xCD 0x26
            0x36 0x4B 0xC5 0xB8 0xE7 0x8F 0x53 0xB8 0x23 0xDD 0xA7 0xF4 0xDE 0x9F 0xAD 0x00
            0xE6 0x7D 0xB7 0x2F 0x9F 0x9F 0xEA 0x0C 0xE3 0xC9 0xFE 0xF1 0x5A 0x76 0xAD 0xC5
            0x85 0xEB 0x2E 0xFD 0x11 0x87 0xFB 0x65 0xF9 0xC9 0xA2 0x73 0x31 0x51 0x67 0xE3
            0x14 0xFA 0x68 0xB6 0xA3 0x22 0xD4 0x07 0x01 0x5D 0x50 0x2A 0xCD 0xEC 0x8C 0x88
            0x5C 0x4F 0x77 0x84 0xCE 0xD0 0x46 0x09 0xBB 0x35 0x15 0x4A 0x96 0x48 0x4B 0x56
            0x25 0xD3 0x41 0x7C 0x88 0x60 0x7A 0xCD 0xE4 0xC2 0xC9 0x9B 0xAE 0x5E 0xDF 0x9E
            0xEA 0x2A 0xD0 0xFB 0x55 0xA2 0x26 0x18 0x9E 0x11 0xD2 0x49 0x60 0x43 0x3E 0x2B
            0x0E 0xE0 0x45 0xA4 0x73 0x09 0x97 0x76 0xDD 0x5D 0xE7 0x39 0xDB 0x9B 0xA8 0x19
            0xD5 0x4C 0xB9 0x03 0xA7 0xA5 0xD7 0xEE
        ];
        keccak_p(&mut state);
        assert_eq!(state, expected_state);
    }

    #[test]
    fn first_n_bytes() {
        let state = expl![
            0xA6 0x9F 0x73 0xCC 0xA2 0x3A 0x9A 0xC5 0xC8 0xB5 0x67 0xDC 0x18 0x5A 0x75 0x6E
            0x97 0xC9 0x82 0x16 0x4F 0xE2 0x58 0x59 0xE0 0xD1 0xDC 0xC1 0x47 0x5C 0x80 0xA6
            0x15 0xB2 0x12 0x3A 0xF1 0xF5 0xF9 0x4C 0x11 0xE3 0xE9 0x40 0x2C 0x3A 0xC5 0x58
            0xF5 0x00 0x19 0x9D 0x95 0xB6 0xD3 0xE3 0x01 0x75 0x85 0x86 0x28 0x1D 0xCD 0x26
            0x36 0x4B 0xC5 0xB8 0xE7 0x8F 0x53 0xB8 0x23 0xDD 0xA7 0xF4 0xDE 0x9F 0xAD 0x00
            0xE6 0x7D 0xB7 0x2F 0x9F 0x9F 0xEA 0x0C 0xE3 0xC9 0xFE 0xF1 0x5A 0x76 0xAD 0xC5
            0x85 0xEB 0x2E 0xFD 0x11 0x87 0xFB 0x65 0xF9 0xC9 0xA2 0x73 0x31 0x51 0x67 0xE3
            0x14 0xFA 0x68 0xB6 0xA3 0x22 0xD4 0x07 0x01 0x5D 0x50 0x2A 0xCD 0xEC 0x8C 0x88
            0x5C 0x4F 0x77 0x84 0xCE 0xD0 0x46 0x09 0xBB 0x35 0x15 0x4A 0x96 0x48 0x4B 0x56
            0x25 0xD3 0x41 0x7C 0x88 0x60 0x7A 0xCD 0xE4 0xC2 0xC9 0x9B 0xAE 0x5E 0xDF 0x9E
            0xEA 0x2A 0xD0 0xFB 0x55 0xA2 0x26 0x18 0x9E 0x11 0xD2 0x49 0x60 0x43 0x3E 0x2B
            0x0E 0xE0 0x45 0xA4 0x73 0x09 0x97 0x76 0xDD 0x5D 0xE7 0x39 0xDB 0x9B 0xA8 0x19
            0xD5 0x4C 0xB9 0x03 0xA7 0xA5 0xD7 0xEE
        ];

        assert_eq!(state.first_n_bytes(3), vec![0xA6, 0x9F, 0x73]);
        assert_eq!(
            state.first_n_bytes(11),
            vec![
                0xA6, 0x9F, 0x73, 0xCC, 0xA2, 0x3A, 0x9A, 0xC5, 0xC8, 0xB5, 0x67
            ]
        );
    }

    #[test]
    fn empty_sha3_512() {
        let expected = vec![
            0xA6, 0x9F, 0x73, 0xCC, 0xA2, 0x3A, 0x9A, 0xC5, 0xC8, 0xB5, 0x67, 0xDC, 0x18, 0x5A,
            0x75, 0x6E, 0x97, 0xC9, 0x82, 0x16, 0x4F, 0xE2, 0x58, 0x59, 0xE0, 0xD1, 0xDC, 0xC1,
            0x47, 0x5C, 0x80, 0xA6, 0x15, 0xB2, 0x12, 0x3A, 0xF1, 0xF5, 0xF9, 0x4C, 0x11, 0xE3,
            0xE9, 0x40, 0x2C, 0x3A, 0xC5, 0x58, 0xF5, 0x00, 0x19, 0x9D, 0x95, 0xB6, 0xD3, 0xE3,
            0x01, 0x75, 0x85, 0x86, 0x28, 0x1D, 0xCD, 0x26,
        ];
        let input: [u8; 0] = [];
        let out = sha3_512(&input);
        assert_eq!(out, expected);
    }
}
